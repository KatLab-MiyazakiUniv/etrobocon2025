@startuml etrobocon2025-class-diagram

package "走行制御システム" {
  ' モーターコントローラークラス
  class MotorController {
    + {static} constexpr MOTOR_POWER_MAX: int
    + {static} constexpr MOTOR_POWER_MIN: int
    + MotorController()
    + setRightMotorPower(int power): void
    + setLeftMotorPower(int power): void
    + resetRightMotorPower(): void
    + resetLeftMotorPower(): void
    + resetWheelsMotorPower(): void
    + setRightMotorSpeed(double speed): void
    + setLeftMotorSpeed(double speed): void
    + stopWheelsMotor(): void
    + brakeWheelsMotor(): void
    + setArmMotorPower(int power): void
    + resetArmMotorPower(): void
    + stopArmMotor(): void
    + holdArmMotor(): void
    + getRightMotorCount(): int32_t
    + getLeftMotorCount(): int32_t
    + getArmMotorCount(): int32_t
    + getRightMotorPower(): int
    + getLeftMotorPower(): int
    + getArmMotorPower(): int
    + getRightMotorSpeed(): double
    + getLeftMotorSpeed(): double
    - rightWheel: spikeapi::Motor
    - leftWheel: spikeapi::Motor
    - armMotor: spikeapi::Motor
    - limitPowerValue(int inputPower): int
  }

  ' PIDクラス
  class Pid {
    + Pid(double _kp, double _ki, double _kd, double _targetValue, double _maxIntegral, double _minIntegral)
    + Pid(double _kp, double _ki, double _kd, double _targetValue)
    + setPidGain(double _kp, double _ki, double _kd): void
    + calculatePid(double currentValue, double delta): double
    - pidGain: PidGain
    - prevDeviation: double
    - integral: double
    - filteredDerivative: double
    - targetValue: double
    - maxIntegral: double
    - minIntegral: double
    - {static} constexpr alpha: double
  }

  ' 色判定クラス
  class ColorJudge {
    + ColorJudge()
    + {static} convertStringToColor(const std::string& str): COLOR
    + {static} convertColorToString(const COLOR& color): const char*
    + {static} convertHsvToColor(const spikeapi::ColorSensor::HSV& hsv): COLOR
    - ColorJudge()
  }

  ' 走行距離計算クラス
  class Mileage {
    + {static} calculateWheelMileage(int32_t angle): double
    + {static} calculateMileage(int32_t rightAngle, int32_t leftAngle): double
    - Mileage()
  }

  ' 速度計算クラス
  class SpeedCalculator {
    + SpeedCalculator(Robot& _robot, double _targetSpeed)
    + calculateRightMotorPower(): double
    + calculateLeftMotorPower(): double
    - const targetSpeed: double
    - rightPid: Pid
    - leftPid: Pid
    - rightMotorPower: double
    - leftMotorPower: double
    - prevRightTime: double
    - prevLeftTime: double
    - robot: Robot&
    - {static} constexpr RIGHT_K_P: double
    - {static} constexpr RIGHT_K_I: double
    - {static} constexpr RIGHT_K_D: double
    - {static} constexpr LEFT_K_P: double
    - {static} constexpr LEFT_K_I: double
    - {static} constexpr LEFT_K_D: double
  }

  ' Motionクラス
  abstract class Motion {
    + Motion(Robot& _robot)
    + {abstract} run(): void
    # robot: Robot&
  }

  abstract class LineTrace {
    + LineTrace(Robot& _robot, double _targetSpeed, int _targetBrightness, const PidGain& _pidGain)
    + run(): void
    # {abstract} isMetPreCondition(): bool
    # {abstract} prepare(): void
    # {abstract} isMetContinuationCondition(): bool
    # targetSpeed: double
    # targetBrightness: int
    # pidGain: PidGain
  }

  abstract class Straight {
    + Straight(Robot& _robot, double _speed)
    + run(): void
    # {abstract} isMetPreCondition(): bool
    # {abstract} prepare(): void
    # {abstract} isMetContinuationCondition(): bool
    # targetSpeed: double
  }

  abstract class Rotation {
    + Rotation(Robot& _robot, double _speed, bool _isClockwise)
    + run(): void
    + {abstract} isMetPreCondition(): bool
    + {abstract} prepare(): void
    + {abstract} isMetContinuationCondition(): bool
    # speed: double
    # isClockwise: bool
    # leftSign: int
    # rightSign: int
  }

  ' 色指定ライントレースクラス
  class ColorLineTrace {
    + ColorLineTrace(Robot& _robot, COLOR _targetColor, double _targetSpeed, int _targetBrightness, const PidGain& _gain)
    # isMetPreCondition(): bool
    # prepare(): void
    # isMetContinuationCondition(): bool
    - {static} constexpr JUDGE_COUNT: int
    - colorCount: int
    - targetColor: COLOR
  }

  ' 距離指定ライントレースクラス
  class DistanceLineTrace {
    + DistanceLineTrace(Robot& _robot, double _targetDistance, double _targetSpeed, int _targetBrightness, const PidGain& _pidGain)
    # isMetPreCondition(): bool
    # prepare(): void
    # isMetContinuationCondition(): bool
    - targetDistance: double
    - initDistance: double
  }

  ' 色距離指定ライントレースクラス
  class ColorDistanceLineTrace {
    + ColorDistanceLineTrace(Robot& _robot, COLOR _targetColor, double _targetDistance, double _targetSpeed, int _targetBrightness, const PidGain& _pidGain)
    # isMetPreCondition(): bool
    # prepare(): void
    # isMetContinuationCondition(): bool
    - {static} constexpr JUDGE_COUNT: int
    - colorCount: int
    - targetColor: COLOR
    - targetDistance: double
    - initDistance: double
  }

  ' 距離指定直進クラス
  class DistanceStraight {
    + DistanceStraight(Robot& _robot, double _targetDistance, double _speed)
    # isMetPreCondition(): bool
    # prepare(): void
    # isMetContinuationCondition(): bool
    - targetDistance: double
    - initialDistance: double
  }

  ' 色指定直進クラス
  class ColorStraight {
    + ColorStraight(Robot& _robot, COLOR _targetColor, double _speed)
    # isMetPreCondition(): bool
    # prepare(): void
    # isMetContinuationCondition(): bool
    - colorCount: int
    - targetColor: COLOR
    - {static} constexpr JUDGE_COUNT: int
  }

  ' 角度指定回頭クラス
  class AngleRotation {
    + AngleRotation(Robot& _robot, int _targetAngle, double _speed, bool _isClockwise)
    # prepare(): void
    # isMetPreCondition(): bool
    # isMetContinuationCondition(): bool
    - targetLeftDistance: double
    - targetRightDistance: double
    - targetAngle: int
  }

  ' カメラPID監視クラス
  abstract class CameraPidTracking {
    + CameraPidTracking(Robot& _robot, double _targetSpeed, int _targetXCoordinate, const PidGain& _pidGain, BoundingBoxDetector& _boundingBoxDetector)
    + run(): void
    # {abstract} isMetPreCondition(): bool
    # {abstract} prepare(): void
    # {abstract} isMetContinuationCondition(): bool
    # boundingBoxDetector: BoundingBoxDetector&
    # result: BoundingBoxDetectionResult
    # targetSpeed: double
    # targetXCoordinate: int
    # pidGain: PidGain
  }

  ' 距離指定カメラライントレースクラス
  class DistanceCameraLineTrace {
    + DistanceCameraLineTrace(Robot& _robot, double _targetDistance, double _targetSpeed, int _targetXCoordinate, const PidGain& _pidGain, std::unique_ptr<BoundingBoxDetector> _detector)
    # isMetPreCondition(): bool
    # prepare(): void
    # isMetContinuationCondition(): bool
    - targetDistance: double
    - initDistance: double
    - detector: std::unique_ptr<BoundingBoxDetector>
  }

  ' エッジ変更クラス
  class EdgeChange {
    + EdgeChange(Robot& _robot, bool _isLeftEdge)
    + run(): void
    - isLeftEdge: bool
  }

  ' スリープクラス
  class Sleeping {
    + Sleeping(Robot& _robot, int _milliSec)
    + run(): void
    - milliSec: int
  }

  enum COLOR {
    NONE
    BLACK
    WHITE
    BLUE
    GREEN
    YELLOW
    RED
  }

  struct PidGain {
    + kp: double
    + ki: double
    + kd: double
    + PidGain(double _kp, double _ki, double _kd)
  }

  ' 応用動作クラス
  abstract class CompositeMotion {
    + CompositeMotion(Robot& _robot)
    + {abstract} run(): void
  }

  ' ミニフィグカメラアクション
  class MiniFigCameraAction {
    + MiniFigCameraAction(Robot& _robot, bool _isClockwise, int _preTargetAngle, int _postTargetAngle, double _targetRotationSpeed, double _backTargetDistance, double _forwardTargetDistance, double _backSpeed, double _forwardSpeed, int _position)
    + run(): void
    - isClockwise: bool
    - preTargetAngle: int
    - postTargetAngle: int
    - targetRotationSpeed: double
    - backTargetDistance: double
    - forwardTargetDistance: double
    - backSpeed: double
    - forwardSpeed: double
    - position: int
    - {static} constexpr filePath: const char*
    - {static} constexpr uploadFileName: const char*
    - isMetPreCondition(): bool
    - detectDirection(cv::Mat& frame): void
  }

  ' プラレール撮影動作クラス
  class PlaCameraAction {
    + PlaCameraAction(Robot& _robot, double _threshold, double _minArea, const cv::Rect& _roi)
    + run(): void
    - getBackgroundFrame(): void
    - motionDetector: MotionDetector
    - {static} constexpr MAX_NO_MOTION: int
    - {static} constexpr filePath: const char*
    - {static} constexpr uploadFile: const char*
  }

  ' システム定数
  class SystemInfo <<constants>> {
    + {static} PI: double
    + {static} RAD_TO_DEG: double
    + {static} DEG_TO_RAD: double
    + {static} constexpr TREAD: double
    + {static} constexpr WHEEL_RADIUS: double
    + {static} constexpr RESOLUTION_WIDTH: int
    + {static} constexpr RESOLUTION_HEIGHT: int
    + {static} constexpr MIN_WIDTH: int
    + {static} constexpr MIN_HEIGHT: int
    + {static} constexpr MAX_WIDTH: int
    + {static} constexpr MAX_HEIGHT: int
  }
}

package "カメラ撮影システム" {
  ' カメラキャプチャーインターフェース
  abstract class ICameraCapture {
    + {abstract} ~ICameraCapture()
    + {abstract} findAvailableCameraID(int maxTested): int
    + {abstract} getCameraID(): int
    + {abstract} setCameraID(int id): bool
    + {abstract} openCamera(): bool
    + {abstract} setCapProps(double width, double height): void
    + {abstract} getFrame(cv::Mat& outFrame): bool
  }

  ' カメラキャプチャークラス
  class CameraCapture {
    + CameraCapture()
    + ~CameraCapture()
    + findAvailableCameraID(int maxTested): int
    + getCameraID(): int
    + setCameraID(int id): bool
    + openCamera(): bool
    + setCapProps(double width, double height): void
    + getFrame(cv::Mat& outFrame): bool
    - cap: cv::VideoCapture
    - cameraID: int
  }

  ' スナップショットクラス
  class Snapshot {
    + Snapshot(Robot& _robot, const std::string& _fileName)
    + run(): void
    - fileName: std::string
    - {static} const path: std::string
  }

  ' 画像処理系
  struct BoundingBoxDetectionResult {
    + wasDetected: bool
    + topLeft: cv::Point
    + topRight: cv::Point
    + bottomLeft: cv::Point
    + bottomRight: cv::Point
  }

  abstract class BoundingBoxDetector {
    + {abstract} ~BoundingBoxDetector()
    + {abstract} detect(const cv::Mat& frame, BoundingBoxDetectionResult& result): void
  }

  class LineBoundingBoxDetector {
    + LineBoundingBoxDetector(const cv::Scalar& _lowerHSV, const cv::Scalar& _upperHSV)
    + LineBoundingBoxDetector(const cv::Scalar& lowerHSV, const cv::Scalar& upperHSV, const cv::Rect& roi)
    + LineBoundingBoxDetector(const cv::Scalar& lowerHSV, const cv::Scalar& upperHSV, const cv::Rect& roi, const cv::Size& resolution)
    + detect(const cv::Mat& frame, BoundingBoxDetectionResult& result): void
    - {static} MIN_LINE_CONTOUR_AREA: double
    - lowerHSV: cv::Scalar
    - upperHSV: cv::Scalar
    - roi: cv::Rect
    - resolution: cv::Size
    - validateParameters(): void
  }

  ' フレーム保存クラス
  class FrameSave {
    + {static} save(cv::Mat& frame, const std::string& filePath, const std::string& fileName): void
    - FrameSave()
    - {static} inline imgExtension: std::string
  }
}

package "配置エリアB撮影システム" {
  class MotionDetector {
    + MotionDetector(double _threshold, double _minArea, const cv::Rect& _roi)
    + setBackground(const cv::Mat& background): bool
    + detect(const cv::Mat& frame, BoundingBoxDetectionResult& result): void
    + compareTwoFrames(const cv::Mat& firstFrame, const cv::Mat& secondFrame): std::vector<cv::Point>
    - threshold: double
    - minArea: double
    - roi: cv::Rect
    - bgFrame: cv::Mat
  }

  enum BackgroundDirection {
    FRONT
    BACK
    RIGHT
    LEFT
  }

  struct BackgroundDirectionResult {
    + wasDetected: bool
    + direction: BackgroundDirection
  }

  class BackgroundDirectionDetector {
    + BackgroundDirectionDetector(const std::string& modelPath)
    + detect(const cv::Mat& frame, BackgroundDirectionResult& result): void
    - net: cv::dnn::Net
    - modelPath: std::string
    - outputImagePath: std::string
    - preprocess(const cv::Mat& frame, float scale, int padX, int padY): cv::Mat
    - postprocess(const std::vector<cv::Mat>& outputs, const cv::Mat& frame, float scale, int padX, int padY, BackgroundDirectionResult& result): void
  }
}

package "配置エリアA撮影システム" {
  enum MiniFigDirection {
    FRONT
    RIGHT
    BACK
    LEFT
  }

  struct MiniFigDirectionResult {
    + wasDetected: bool
    + direction: MiniFigDirection
  }

  class MiniFigDirectionDetector {
    + MiniFigDirectionDetector(const std::string& modelPath)
    + detect(const cv::Mat& frame, MiniFigDirectionResult& result): void
    - net: cv::dnn::Net
    - modelPath: std::string
    - outputImagePath: std::string
    - preprocess(const cv::Mat& frame, float scale, int padX, int padY): cv::Mat
    - postprocess(const std::vector<cv::Mat>& outputs, const cv::Mat& frame, float scale, int padX, int padY, MiniFigDirectionResult& result): void
  }
}

package "走行体・無線通信デバイス間通信システム" {
}

package "画像アップロードシステム" {
}

package "ロボコンスナップ攻略システム" {

  ' コマンドの列挙型
  enum COMMAND {
    AR
    DS
    CS
    DL
    DCL
    CL
    CDL
    EC
    SL
    SS
    MCA
    NONE
  }

  ' 攻略エリアの列挙型
  enum Area {
    LineTrace
    DoubleLoop
    SmartCarry
  }

  ' メインクラス
  class EtRobocon2025 {
    + {static} start(): void
    - {static} robot: Robot
  }

  ' ロボットクラス
  class Robot {
    + Robot()
    + Robot(ICameraCapture& cam)
    + getMotorControllerInstance(): MotorController&
    + getCameraCaptureInstance(): ICameraCapture&
    + getColorSensorInstance(): spikeapi::ColorSensor&
    + getClockInstance(): spikeapi::Clock&
    + getButtonInstance(): spikeapi::Button&
    + getForceSensorInstance(): spikeapi::ForceSensor&
    + getDisplayInstance(): spikeapi::Display&
    + setIsLeftEdge(bool isLeft): void
    + getIsLeftEdge() const: bool
    + getMiniFigDirectionResult(): MiniFigDirectionResult&
    - motorController: MotorController
    - defaultCameraCapture: CameraCapture
    - cameraCapture: ICameraCapture&
    - colorSensor: spikeapi::ColorSensor
    - clock: spikeapi::Clock
    - button: spikeapi::Button
    - forceSensor: spikeapi::ForceSensor
    - display: spikeapi::Display
    - miniFigDirectionResult: MiniFigDirectionResult
    - isLeftEdge: bool
  }

  ' エリアマスタークラス
  class AreaMaster {
    + AreaMaster(Robot& _robot, Area _area, bool _isLeftCourse, int _targetBrightness)
    + run(): void
    - robot: Robot&
    - area: Area
    - isLeftCourse: bool
    - targetBrightness: int
    - {static} const basePath: std::string
    - {static} const areaCommandNames: std::array<std::string, 3>
  }

  ' キャリブレータクラス
  class Calibrator {
    + Calibrator(Robot& _robot)
    + selectAndSetCourse(): void
    + measureAndSetTargetBrightness(): void
    + getAngleCheckFrame(): void
    + waitForStart(): void
    + getIsLeftCourse(): bool
    + getTargetBrightness(): int
    - robot: Robot&
    - isLeftCourse: bool
    - targetBrightness: int
  }

  ' モーションパーサークラス
  class MotionParser {
    + {static} createMotions(Robot& robot, std::string& commandFilePath, int targetBrightness): std::vector<Motion*>
    - MotionParser()
    - {static} convertCommand(const std::string& str): COMMAND
    - {static} convertBool(const std::string& command, const std::string& stringParameter): bool
  }

  ' ユーティリティクラス
  class StringOperator {
    + {static} removeEOL(const std::string& str): std::string
    - StringOperator()
  }
}

' 関係性の定義

' 1. 継承関係 (Inheritance)
LineTrace --|> Motion : 継承
Straight --|> Motion : 継承
Rotation --|> Motion : 継承
CameraPidTracking --|> Motion : 継承
CompositeMotion --|> Motion : 継承

DistanceLineTrace --|> LineTrace : 継承
ColorLineTrace --|> LineTrace : 継承
ColorDistanceLineTrace --|> LineTrace : 継承

DistanceStraight --|> Straight : 継承
ColorStraight --|> Straight : 継承

AngleRotation --|> Rotation : 継承

DistanceCameraLineTrace --|> CameraPidTracking : 継承

MiniFigCameraAction --|> CompositeMotion : 継承

EdgeChange --|> Motion : 継承
Sleeping --|> Motion : 継承
Snapshot --|> Motion : 継承
PlaCameraAction --|> Motion : 継承

LineBoundingBoxDetector --|> BoundingBoxDetector : 継承
MotionDetector --|> BoundingBoxDetector : 継承

' 2. 実現関係 (Realization)
CameraCapture ..|> ICameraCapture : 実現

' 3. コンポジション関係 (Composition) - 強い所有関係
EtRobocon2025 *-- Robot : コンポジション
Robot *-- MotorController : コンポジション
Robot *-- CameraCapture : コンポジション
Robot *-- "spikeapi::ColorSensor" : コンポジション
Robot *-- "spikeapi::Clock" : コンポジション
Robot *-- "spikeapi::Button" : コンポジション
Robot *-- "spikeapi::ForceSensor" : コンポジション
Robot *-- "spikeapi::Display" : コンポジション
Robot *-- MiniFigDirectionResult : コンポジション

MotorController *-- "spikeapi::Motor" : コンポジション

Pid *-- PidGain : コンポジション

SpeedCalculator *-- Pid : コンポジション

PlaCameraAction *-- MotionDetector : コンポジション

' 4. 集約関係 (Aggregation) - 弱い所有関係
Robot o-- ICameraCapture : 集約
CameraPidTracking o-- BoundingBoxDetector : 集約
DistanceCameraLineTrace o-- BoundingBoxDetector : 集約

' 5. 関連関係 (Association) - 永続的な関係
AreaMaster --> Robot : 関連
Calibrator --> Robot : 関連
Motion --> Robot : 関連

' 6. 依存関係 (Dependency) - 一時的な使用関係
AreaMaster ..> MotionParser : 依存
AreaMaster ..> Area : 依存

MotionParser ..> Motion : 依存
MotionParser ..> COMMAND : 依存
MotionParser ..> ColorLineTrace : 依存
MotionParser ..> DistanceLineTrace : 依存
MotionParser ..> ColorDistanceLineTrace : 依存
MotionParser ..> DistanceStraight : 依存
MotionParser ..> ColorStraight : 依存
MotionParser ..> AngleRotation : 依存
MotionParser ..> DistanceCameraLineTrace : 依存
MotionParser ..> EdgeChange : 依存
MotionParser ..> Sleeping : 依存
MotionParser ..> Snapshot : 依存
MotionParser ..> MiniFigCameraAction : 依存

LineTrace ..> PidGain : 依存
LineTrace ..> ColorJudge : 依存
LineTrace ..> Mileage : 依存
LineTrace ..> SpeedCalculator : 依存

Straight ..> SpeedCalculator : 依存

AngleRotation ..> Mileage : 依存
AngleRotation ..> SystemInfo : 依存

ColorLineTrace ..> COLOR : 依存
ColorStraight ..> COLOR : 依存
ColorDistanceLineTrace ..> COLOR : 依存

BoundingBoxDetector ..> BoundingBoxDetectionResult : 依存
LineBoundingBoxDetector ..> BoundingBoxDetectionResult : 依存
MotionDetector ..> BoundingBoxDetectionResult : 依存
CameraPidTracking ..> PidGain : 依存
CameraPidTracking ..> BoundingBoxDetectionResult : 依存

BackgroundDirectionDetector ..> BackgroundDirectionResult : 依存
BackgroundDirectionDetector ..> BackgroundDirection : 依存

MiniFigDirectionDetector ..> MiniFigDirectionResult : 依存
MiniFigDirectionDetector ..> MiniFigDirection : 依存

Snapshot ..> FrameSave : 依存
MiniFigCameraAction ..> FrameSave : 依存
MiniFigCameraAction ..> MiniFigDirectionDetector : 依存
MiniFigCameraAction ..> AngleRotation : 依存
MiniFigCameraAction ..> DistanceStraight : 依存
PlaCameraAction ..> FrameSave : 依存
MotionDetector ..> FrameSave : 依存


@enduml
